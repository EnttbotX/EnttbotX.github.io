<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grabador en tiempo real</title>
  <style>
    body { font-family: sans-serif; max-width: 800px; margin: 20px auto; padding: 10px; }
    button { margin-right: 10px; padding: 8px 12px; }
    canvas { border: 1px solid #444; width: 100%; height: 150px; }
    input[type=range] { width: 100%; }
  </style>
</head>
<body>
  <h1>Grabador en tiempo real</h1>
  <p>Grabá el micrófono y escuchá un sonido de fondo que no se graba.</p>

  <button id="init">Inicializar audio</button>
  <button id="toggleRecord">Iniciar grabación</button>
  <button id="toggleBg">Añadir/Play fondo (solo en vivo)</button>

  <div>
    <label>Vol micrófono</label>
    <input id="micGain" type="range" min="0" max="2" step="0.01" value="1">
  </div>
  <div>
    <label>Vol fondo (solo en vivo)</label>
    <input id="bgGain" type="range" min="0" max="2" step="0.01" value="0.5">
  </div>

  <canvas id="visual"></canvas>

  <h3>Preview grabación</h3>
  <audio id="playback" controls></audio>
  <a id="download" href="#" download style="display:none;">Descargar</a>

  <script>
    let audioCtx, analyser, micSrc, micGainNode, bgGainNode, bgSrc, bgEl, dest, mediaRecorder
    let chunks = [], recording = false
    const canvas = document.getElementById('visual')
    const ctx = canvas.getContext('2d')

    async function initAudio() {
      try {
        if (audioCtx) { await audioCtx.resume(); return }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
        const AC = window.AudioContext || window.webkitAudioContext
        audioCtx = new AC()
        if (audioCtx.state === "suspended") await audioCtx.resume()
        micSrc = audioCtx.createMediaStreamSource(stream)
        micGainNode = audioCtx.createGain()
        analyser = audioCtx.createAnalyser()
        analyser.fftSize = 2048
        dest = audioCtx.createMediaStreamDestination()
        micSrc.connect(micGainNode)
        micGainNode.connect(analyser)
        analyser.connect(audioCtx.destination)
        micGainNode.connect(dest)
        bgEl = new Audio()
        bgEl.loop = true
        bgSrc = audioCtx.createMediaElementSource(bgEl)
        bgGainNode = audioCtx.createGain()
        bgGainNode.gain.value = parseFloat(document.getElementById('bgGain').value)
        bgSrc.connect(bgGainNode)
        bgGainNode.connect(audioCtx.destination)
        draw()
      } catch (err) {
        alert("No se pudo acceder al micrófono: " + err.message)
      }
    }

    function draw() {
      requestAnimationFrame(draw)
      const buffer = new Uint8Array(analyser.fftSize)
      analyser.getByteTimeDomainData(buffer)
      ctx.clearRect(0,0,canvas.width,canvas.height)
      ctx.beginPath()
      const slice = canvas.width / buffer.length
      for (let i = 0; i < buffer.length; i++) {
        const v = buffer[i] / 128.0
        const y = v * canvas.height / 2
        if (i === 0) ctx.moveTo(0, y)
        else ctx.lineTo(i * slice, y)
      }
      ctx.stroke()
    }

    function startRecording() {
      mediaRecorder = new MediaRecorder(dest.stream)
      chunks = []
      mediaRecorder.ondataavailable = e => chunks.push(e.data)
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/webm' })
        const url = URL.createObjectURL(blob)
        document.getElementById('playback').src = url
        const a = document.getElementById('download')
        a.href = url
        a.download = 'grabacion_' + Date.now() + '.webm'
        a.style.display = 'inline'
      }
      mediaRecorder.start()
      recording = true
      document.getElementById('toggleRecord').innerText = 'Detener grabación'
    }

    function stopRecording() {
      mediaRecorder.stop()
      recording = false
      document.getElementById('toggleRecord').innerText = 'Iniciar grabación'
    }

    function toggleBg() {
      if (!bgEl.src) {
        const input = document.createElement('input')
        input.type = 'file'
        input.accept = 'audio/*'
        input.onchange = e => {
          const file = e.target.files[0]
          if (!file) return
          bgEl.src = URL.createObjectURL(file)
          bgEl.play()
          audioCtx.resume()
        }
        input.click()
      } else {
        if (bgEl.paused) { bgEl.play(); audioCtx.resume() }
        else bgEl.pause()
      }
    }

    document.getElementById('init').onclick = initAudio
    document.getElementById('toggleRecord').onclick = () => {
      if (!audioCtx) return alert('Primero inicializá el audio')
      recording ? stopRecording() : startRecording()
    }
    document.getElementById('toggleBg').onclick = toggleBg
    document.getElementById('micGain').oninput = e => {
      if (micGainNode) micGainNode.gain.value = parseFloat(e.target.value)
    }
    document.getElementById('bgGain').oninput = e => {
      if (bgGainNode) bgGainNode.gain.value = parseFloat(e.target.value)
    }
  </script>
</body>
</html>