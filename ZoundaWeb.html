<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Grabador con selección de dispositivos</title>
<style>
body { font-family: sans-serif; max-width: 800px; margin: 20px auto; }
button,input,select { margin:5px; }
canvas { border:1px solid #444; width:100%; height:150px; }
</style>
</head>
<body>
<h2>Grabador avanzado</h2>

<label>Micrófono: </label>
<select id="micSelect"></select>
<label>Salida: </label>
<select id="outSelect"></select><br>

<button id="init">Inicializar audio</button>
<button id="toggleRecord">Iniciar grabación</button>
<button id="toggleBg">Añadir/Play fondo (solo en vivo)</button>

<label>Vol micrófono</label><input id="micGain" type="range" min="0" max="2" step="0.01" value="1">
<label>Vol fondo</label><input id="bgGain" type="range" min="0" max="2" step="0.01" value="0.5">

<canvas id="visual"></canvas>
<audio id="playback" controls></audio>
<a id="download" href="#" download style="display:none;">Descargar</a>

<script>
let audioCtx, analyser, micSrc, micGainNode, bgGainNode, bgSrc, bgEl, dest, mediaRecorder;
let chunks=[], recording=false;

const canvas = document.getElementById('visual');
const ctx = canvas.getContext('2d');

async function listDevices() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const mics = devices.filter(d=>d.kind==='audioinput');
  const outs = devices.filter(d=>d.kind==='audiooutput');
  const micSelect = document.getElementById('micSelect');
  const outSelect = document.getElementById('outSelect');
  mics.forEach(d=>micSelect.add(new Option(d.label||d.deviceId,d.deviceId)));
  outs.forEach(d=>outSelect.add(new Option(d.label||d.deviceId,d.deviceId)));
}

async function initAudio() {
  if (audioCtx) { await audioCtx.resume(); return; }
  const micId = document.getElementById('micSelect').value;
  const stream = await navigator.mediaDevices.getUserMedia({ audio:{deviceId:micId?{exact:micId}:undefined} });
  const AC = window.AudioContext || window.webkitAudioContext;
  audioCtx = new AC();
  if(audioCtx.state==="suspended") await audioCtx.resume();

  micSrc = audioCtx.createMediaStreamSource(stream);
  micGainNode = audioCtx.createGain();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize=2048;
  dest = audioCtx.createMediaStreamDestination();

  micSrc.connect(micGainNode);
  micGainNode.connect(analyser);
  analyser.connect(audioCtx.destination);
  micGainNode.connect(dest);

  bgEl = new Audio();
  bgEl.loop=true;
  bgSrc = audioCtx.createMediaElementSource(bgEl);
  bgGainNode = audioCtx.createGain();
  bgGainNode.gain.value=parseFloat(document.getElementById('bgGain').value);
  bgSrc.connect(bgGainNode);
  bgGainNode.connect(audioCtx.destination);

  const outId = document.getElementById('outSelect').value;
  if(outId && typeof document.getElementById('playback').setSinkId==='function') {
    document.getElementById('playback').setSinkId(outId).catch(console.warn);
  }

  draw();
}

function draw() {
  requestAnimationFrame(draw);
  const buffer=new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(buffer);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.beginPath();
  const slice=canvas.width/buffer.length;
  for(let i=0;i<buffer.length;i++){
    const v=buffer[i]/128.0;
    const y=v*canvas.height/2;
    if(i===0) ctx.moveTo(0,y);
    else ctx.lineTo(i*slice,y);
  }
  ctx.stroke();
}

function startRecording(){
  mediaRecorder=new MediaRecorder(dest.stream);
  chunks=[];
  mediaRecorder.ondataavailable=e=>chunks.push(e.data);
  mediaRecorder.onstop=()=>{
    const blob=new Blob(chunks,{type:'audio/webm'});
    const url=URL.createObjectURL(blob);
    const a=document.getElementById('download');
    document.getElementById('playback').src=url;
    a.href=url; a.download='grabacion_'+Date.now()+'.webm'; a.style.display='inline';
  };
  mediaRecorder.start();
  recording=true;
  document.getElementById('toggleRecord').innerText='Detener grabación';
}

function stopRecording(){ mediaRecorder.stop(); recording=false; document.getElementById('toggleRecord').innerText='Iniciar grabación'; }

function toggleBg(){
  if(!bgEl.src){
    const input=document.createElement('input');
    input.type='file'; input.accept='audio/*';
    input.onchange=e=>{const f=e.target.files[0]; if(!f) return; bgEl.src=URL.createObjectURL(f); bgEl.play(); audioCtx.resume();}
    input.click();
  }else{ bgEl.paused?bgEl.play():bgEl.pause(); }
}

document.getElementById('init').onclick=initAudio;
document.getElementById('toggleRecord').onclick=()=>{ if(!audioCtx) return alert('Inicializa audio'); recording?stopRecording():startRecording();}
document.getElementById('toggleBg').onclick=toggleBg;
document.getElementById('micGain').oninput=e=>{ if(micGainNode) micGainNode.gain.value=parseFloat(e.target.value);}
document.getElementById('bgGain').oninput=e=>{ if(bgGainNode) bgGainNode.gain.value=parseFloat(e.target.value);}
listDevices();
</script>
</body>
</html>  <script>
    let audioCtx, analyser, micSrc, micGainNode, bgGainNode, bgSrc, bgEl, dest, mediaRecorder
    let chunks = [], recording = false
    const canvas = document.getElementById('visual')
    const ctx = canvas.getContext('2d')

    async function initAudio() {
      try {
        if (audioCtx) { await audioCtx.resume(); return }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
        const AC = window.AudioContext || window.webkitAudioContext
        audioCtx = new AC()
        if (audioCtx.state === "suspended") await audioCtx.resume()
        micSrc = audioCtx.createMediaStreamSource(stream)
        micGainNode = audioCtx.createGain()
        analyser = audioCtx.createAnalyser()
        analyser.fftSize = 2048
        dest = audioCtx.createMediaStreamDestination()
        micSrc.connect(micGainNode)
        micGainNode.connect(analyser)
        analyser.connect(audioCtx.destination)
        micGainNode.connect(dest)
        bgEl = new Audio()
        bgEl.loop = true
        bgSrc = audioCtx.createMediaElementSource(bgEl)
        bgGainNode = audioCtx.createGain()
        bgGainNode.gain.value = parseFloat(document.getElementById('bgGain').value)
        bgSrc.connect(bgGainNode)
        bgGainNode.connect(audioCtx.destination)
        draw()
      } catch (err) {
        alert("No se pudo acceder al micrófono: " + err.message)
      }
    }

    function draw() {
      requestAnimationFrame(draw)
      const buffer = new Uint8Array(analyser.fftSize)
      analyser.getByteTimeDomainData(buffer)
      ctx.clearRect(0,0,canvas.width,canvas.height)
      ctx.beginPath()
      const slice = canvas.width / buffer.length
      for (let i = 0; i < buffer.length; i++) {
        const v = buffer[i] / 128.0
        const y = v * canvas.height / 2
        if (i === 0) ctx.moveTo(0, y)
        else ctx.lineTo(i * slice, y)
      }
      ctx.stroke()
    }

    function startRecording() {
      mediaRecorder = new MediaRecorder(dest.stream)
      chunks = []
      mediaRecorder.ondataavailable = e => chunks.push(e.data)
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/webm' })
        const url = URL.createObjectURL(blob)
        document.getElementById('playback').src = url
        const a = document.getElementById('download')
        a.href = url
        a.download = 'grabacion_' + Date.now() + '.webm'
        a.style.display = 'inline'
      }
      mediaRecorder.start()
      recording = true
      document.getElementById('toggleRecord').innerText = 'Detener grabación'
    }

    function stopRecording() {
      mediaRecorder.stop()
      recording = false
      document.getElementById('toggleRecord').innerText = 'Iniciar grabación'
    }

    function toggleBg() {
      if (!bgEl.src) {
        const input = document.createElement('input')
        input.type = 'file'
        input.accept = 'audio/*'
        input.onchange = e => {
          const file = e.target.files[0]
          if (!file) return
          bgEl.src = URL.createObjectURL(file)
          bgEl.play()
          audioCtx.resume()
        }
        input.click()
      } else {
        if (bgEl.paused) { bgEl.play(); audioCtx.resume() }
        else bgEl.pause()
      }
    }

    document.getElementById('init').onclick = initAudio
    document.getElementById('toggleRecord').onclick = () => {
      if (!audioCtx) return alert('Primero inicializá el audio')
      recording ? stopRecording() : startRecording()
    }
    document.getElementById('toggleBg').onclick = toggleBg
    document.getElementById('micGain').oninput = e => {
      if (micGainNode) micGainNode.gain.value = parseFloat(e.target.value)
    }
    document.getElementById('bgGain').oninput = e => {
      if (bgGainNode) bgGainNode.gain.value = parseFloat(e.target.value)
    }
  </script>
</body>
</html>
